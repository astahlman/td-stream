* Tasks

** DONE Set up an evaluation harness
   1. [X] Run a bot
   2. [X] Setup a file-based tweet stream
   3. [X] Score the output of the bot

** TODO Implement detection algorithm

** TODO Incorporate scorer identity into scores

** TODO Implement identification algorithm

** TODO Connect the bot to Twitter

* Journal

** <2015-04-27 Mon>
  Struggling with how to reason about the organization of the
  project. I find myself falling back into "The Kingdom of Nouns."
  For example, a Bot detects touchdowns and identifies Scorers given
  a TweetStream. I could define protocols for Bot, TweetStream, etc.,
  but I don't think that would be very Clojure-y, and I want to avoid
  writing Java with parenthesis.

  Found some inspriation from [[http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded][My Clojure Worklflow, Reloaded]] on Stuart
  Sierra's blog. He talks about creating a 'system' map which
  contains all of the necessary components. Then each function takes
  a subset of this system map, according to which pieces of data it
  operates on.
  
  Thinking about it this way helps - My system is just a map comprised
  of a detector (function), a scorer identifier (function), a
  broadcast hook (functions), and a tweet stream (data). No objects
  necessary.
  
  About to take all of the components that I've made part of the bot
  namespace and start putting them into the system map. I'll start
  with the tweet stream. So we'll still have the function
  read-tweets, but now it will accept a tweet-stream and the current
  time. This will allow for two different implementations - one which
  reads from a static file and filters based on the timestamp, and
  one which reads from Twitter in real time. 
  
  Actually, now that I think about it, it probably makes even more
  sense to make the system object a function instead of a thing. Let's
  just have a system-level function called tweet-stream, which accepts
  a single parameter - the time - and returns new tweets.

** <2015-04-28 Tue>
   Someone on SO has found the same [[http://stackoverflow.com/questions/26925557/faking-friend-credential-function-using-midje][issue]] as I have regarding Midje
   not using injected mocked functions at runtime.

   Note: You can use let-bindings inside Midje facts. [[http://www.dysfunctional-programmer.co.uk/clojure/2015/02/28/testing-higher-order-functions-clojure.html][Here's]] an example.

** <2015-05-02 Sat>
   Finally able to reproduce the weird Midje behavior.
   Question: Does passing a Var to a function that destructures it
   and storing the result in a map derefernce the Var?

   Hypothesis: We pass the target function (a Var) to the system
   function. It dereferences this function (what does unfinished do?)
   and stores it in a hash-map, which we then bind to the Var
   'test-system. Then, our precondtions rebind the Var that pointed
   to the target function and point it to our fake implementation.
   This has no effect, because we've already captured the
   implementation that's going to get invoked in the hash-map that
   test-system is bound to.

   Experiment: In the REPL, defn a function called 'fake, which
   returns the keyword :not-mocked. Create a hashmap with
   key :my-fn and value 'fake, and bind it to the Var 'injected.
   Get :my-fn and invoke it - the result should be :not-mocked. Now
   defn 'fake again, so that it's implementation returns :mocked.
   Get :my-fn and invoke it. If the hypothesis above is correct, the
   result should be :not-mocked.

   Result: Yep, as expected, the result is still :not-mocked after
   re-defn'ing fake. This explains why the td-bot example works if I
   inline the creation of the system map in the call to main-loop,
   but not if I def the system map and then pass in a Var to
   main-loop - the function which I'm trying to mock has already been
   captured, and it's already been defined by the unfinished macro to
   throw an exception like "#'fake has no implementation, but it was
   called like this..."

   Ended up answering [[http://stackoverflow.com/questions/26925557/faking-friend-credential-function-using-midje/30008504#30008504][this question]] on StackOverflow and creating
   [[https://gist.github.com/anonymous/9c905325c17e56f7e04a][this]] gist on Github.


** <2015-05-04 Mon>
   Don't have much time tonight. Want to pick something really small
   that I can get done in 20 minutes...


** <2015-05-06 Wed>
   I think I'm close to understand monads. I just started to wonder,
   is there function to simulate a clock, where the clock simply
   increments the time by a fixed value on every tick, but does not
   store any mutable state?

   Now I'm reading
   http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
   The third example for random number generation seems like exactly
   the problem I was wondering about. I feel like I'm right on the
   verge of understanding, but I still don't. The Haskell type
   signatures still seem so bizarre to me. Will revisit this
   tomorrow...

** <2015-05-09 Sat>
   Leaving monads for awhile, going to step away from the theory and
   sling some code. Let's see how far I can get setting up an
   end-to-end test.

** <2015-05-12 Tue>
   Resuming work on the end-to-end test. Currently I'm thinking about
   where and how to introduce state. I know I want to be able to
   simulate a tweet stream based on a file. This means I have to do
   I/O using a file reader. If I were just applying a transformation
   over the contents of the file, I think I could treat it as a
   lazy-sequence. Since I'm reading the file incrementally and
   returning it in chunks, I think I need state, which is stored in
   the file reader. I think I'll need to read lines until I hit a
   tweet whose time > t, then store that in a buffer to be returned
   on the next call. So I'll need a second piece of state, which is
   the buffered tweets to be returned on the next call.

   Got the file-based tweet stream working, just need to start
   parsing JSON. +1 for pragmatism over purity, especially on these
   minor test functions, although I don't regret spending time on it
   since the goal of this project is exploratory learning, anyway.
   

** <2015-05-13 Wed>
   Finishing up the file-based tweet stream, going to add in JSON
   parsing.

   UPDATE: Made good progress tonight. I now have a file-based
   stream, and I can run the bot with dumb implementations of
   touchdown detection and scorer identification, and it works! Now I
   need to figure out a way to signal the end of a stream, or when to
   shutdown the touchdown bot. Right now, the bot will consume the
   entire file and then print "closing..." forever. I think now might
   be a good time to implement the start and shutdown functions, as
   described in Stuart Sierra's My Clojure Worfkow Reloaded post.
   Will think more about this and look into it tomorrow, but off the
   top of my head I'm think of having two functions, start and stop.
   Stop just posts a message to a channel, which main-loop reads from
   on every iteration.
   
   
** <2015-05-15 Fri>
   On an Amtrak, got a few hours. Let's see if I can get a bot that
   runs until the stream signals shutdown, and then gets scored...

** <2015-05-17 Sun>
   Back on an Amtrak bus, should have a little over an an hour.

   Noticed on Friday that my stupid detection function was seriously
   under-detecting touchdowns, even when I changed the function to
   detect a TD every 10 tweets. Realized that I was filtering tweets
   into a tweet window twice, once in the main loop and once in each
   loop step, but in the loop step I was hardcoding the window size
   to 30. Since I'm using epoch time now, that meant that only tweets
   within the last 30 millis of the clock got used. I decided to just
   let the loop step take the old buffer and the new tweets and return
   the new buffer on each iteration. This way, the main loop isn't
   coupled to any specific window size.

   Goal for today: With one command, I should be able to run a bot on
   the test data and get back an F-1 score (which should be very
   close to 0, right now.)

   This will require two independent pieces of data:
   
   1. Each detection event: a map, with keys player and three
      timestamps: the (estimated) time of occurrence, detection, and
      broadcast.
   2. The real touchdowns: also a map, with keys player and one
      timestamp: the actual time of occurrence.
   
   Then we'll need a function that takes detections and truth and
   creates a map of true positives, false positives, and false
   negatives. Then we can feed this to our scoring function. I'll try
   to stick to a top-down development style. So the flow will look
   like:

   1. Create bot.
   2. Create results atom.
   3. Run bot with test-file, collect results in atom.
   4. Label results (true pos, false pos, false neg.)
   5. Score results


** <2015-05-21 Thu>
   I've had a couple of beers and I've got about thirty minutes. I
   seem to remember that last time I was working on labeling events
   as false/true positives/negatives. Guess I'll pick that back up...
   
** <2015-05-23 Sat>
   Long weekend coming up.

*** Goals
    1. [X] Correctly labeling false/true positives/negatives
    2. [X] Scoring labeled results
    3. [X] End-to-end run of a given bot that results in a score

*** Tooling
    :PROPERTIES:
    :tool:     emacs
    :END:
    evil-mode is starting to drive me crazy. Every time a temporary
    stack-trace window pops up from my REPL, I somehow end up back in
    evil-mode and end up in a maddening loop of q-ESC-q-ESC trying to
    get out. I may just disable evil-mode by default, since most of
    what I use emacs for is Lisp-y.

*** Notes
    I should remember that 'reduce' is a good tool in the toolbox. I
    usually find myself (loop recur)ing in situations when I could
    reduce, because it still feels a little more natural in cases
    where I'm iteratively building up some data. I think it made the
    touchdown labeling implementation a little more elegant, though.

    I'm really loving having the REPL around. I have noticed that I
    find myself doing function design bottom-up more often, though -
    not sure how to feel about this. Maybe thinking of every function
    as a data transformation doesn't necessarily require that
    functions be built "up" through successive transformations, but it
    sure seems like the natural development process when I have the
    REPL. Maybe this is a mark of inexperience, and master functional
    programmers synthesize their series of transformations top-down.

    Making great progress today. I've now got a system that, given a
    touchdown bot, feeds it a file-based tweet stream, captures the
    emitted touchdown notifications, and scores the bot's output
    against a known ground-truth.

** <2015-05-24 Sun>
   Starting work on the detection algorithm today. I've already got a
   working R version, so I think it should be relatively
   straightforward. If there's any complexity, I think it will be in
   managing state, i.e., is there already an active event. Not sure
   exactly how that's going to look yet. Maybe the first thing I
   should do is get reacquainted with the algorithm in R.

   Went back to trying to understand monads. I sort of get it, but not
   really. I don't think I will until I devote time to sitting down at
   the REPL with an open notebook to work all of this out. I do *sort
   of* understand the state monad, enough to pick an approach for the
   implementation function. It's basically what I had already decided
   on: the function will accept a hash-map containing state, and it
   will return a vector of the result of the computation and the new
   state.

   All my detection function does is transform the signal to account
   for the length of the tweet text, then compare the signal mean over
   the previous 10 seconds to the threshold for detection. The
   threshold is set as mean(old_window) + (10 * stdev(old_window)). On
   detection, we go into alarm, and wait for the value to fall back
   below the alarm threshold before downgrading.

** <2015-05-25 Mon>
   Picking up the detection algorithm again. But first, I'm disabling
   evil-mode by default - can't take the seemingly random switching
   back and forth.

*** TODO Tooling
    :PROPERTIES:
    :tool:     emacs
    :END:
    I think it might have something to do with the temporary buffer -
    maybe the switch-to-buffer advice doesn't get invoked when I close
    a temporary buffer and go back to the main window. What I really
    want is never to have evil-mode and paredit enabled at the same
    time, and for the cursor to have the appropriate shape, size, and
    color depending on the active mode.

*** Detection Algorithm
    I know I'm going to have to refactor a little to get the state
    passed into the detection algorithm each time. I think that part
    will be easy, so I'm going to focus first on getting the
    detection algorithm working independent of the main loop. I need
    to put some thought into how to test this. I've got the
    end-to-end test case, but it feels like I need something simpler
    to develop against...

** <2015-05-28 Thu>
   Found the bug in my detection algorithm. I was using partition-by
   on the timestamp key to bucketize a sequence of tweets. This
   didn't work because the tweets weren't sorted, so I ended up with
   more buckets than expected.

   Also created a function to plot the signal and store it to disk
   given a sequence of tweets. Still not sure why incanter's view
   function doesn't work, but the saving to /tmp and opening in
   terminal isn't bothering me too much, yet. If it gets annoying I
   could even work around by creating an elisp function to open the
   resulting file from eshell.

   Up next: refactor the main loop. There's some work needed to
   capture the tweet buffer and the state of the detection algorithm
   and feed it back in on each iteration. Tests will need to be
   updated as well. Really starting to question the value of tests
   that make assertions about the presence or non-presence of calls
   in functional languages.

   Open question: Do Midje tests using prerequisites add value once
   you start implementing the mocked function? Or do they just slow
   down development and refactoring?

   Although, now that I think about it... I think they do add some
   value, at least. If function A depends on function B, and the
   signature of function B changes, when I have a test for function A
   that mocks function B, I know right away that the failure lies in
   the fact that the expected (incorrectly mocked) call was never made
   to function B.

   On the other hand, wouldn't a stack-trace to the actual call to B
   tell me roughly the same thing, and free me from having to update
   the tests for function A when I change function B.

   I guess the advantage of mocking in a functional language is the
   same advantage of mocking classes in the OO world. If my test
   starts failing because module or function B is incorrect, my tests
   for module or function A, which depends on B, will still pass, and
   the failure is isolated to module or function B, and therefore
   easily traceable. The difference is that in a strongly typed
   environment, changing the interface of B would break A's tests,
   whereas in a dynamically typed environment, I can change the
   interface of B without touching any of A's tests, provided that I
   haven't mocked out the calls to B in A's tests.

   Will have to revisit this as I garner more practical experience
   with Clojure testing. This could result in a potentially
   interesting (well, to me at least) blog post.

** <2015-06-04 Thu>
   Got a half-hour or so. Will go back to refactoring the main loop
   and the loop-step.

   Update: Got some good refactoring done. The main loop and the loop
   step and all their tests are now updated to use a td-detection
   function that retuns an alarm value, a tweet buffer, and a list of
   detections. All the tests seem to be passing, so I think the next
   step is to start debugging the detection function via the
   acceptance test. This will probably take some infrastructural work
   to visualize what's going on over time in the detection functions,
   as right now it's mostly a black-box.
